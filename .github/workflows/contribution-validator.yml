name: Contribution Validator

on:
  pull_request:
    types: [opened, synchronize, edited]
permissions:
  contents: read
  pull-requests: write
  statuses: write

jobs:
  validate-contributions:
    name: Validate Against Contribution Guidelines
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: |
      github.event.pull_request.additions < 10000 &&
      github.event.pull_request.changed_files < 100 &&
      github.event.pull_request.commits < 50

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.base_ref }}

      - name: Read Contributing Guidelines
        id: guidelines
        run: |
          GUIDELINES=$(cat CONTRIBUTING.md)
          echo "GUIDELINES<<EOF" >> $GITHUB_OUTPUT
          echo "$GUIDELINES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get PR Information
        id: pr-info
        run: |
          # Get PR title and description
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          PR_COMMITS="${{ github.event.pull_request.commits }}"

          # Get commit messages from the PR
          COMMIT_MESSAGES=$(gh pr view ${{ github.event.number }} \
            --json commits --jq '.commits[].messageHeadline' | head -20)

          # Get files changed in the PR for context
          FILES_CHANGED=$(gh pr view ${{ github.event.number }} \
            --json files --jq '.files[].path' | head -10)

          # Get a summary of changes (first few lines of diff)
          CHANGES_SUMMARY=$(gh pr diff ${{ github.event.number }} | head -50)

          # Format for AI validation
          echo "PR_TITLE=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "PR_BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "PR_COMMITS=$PR_COMMITS" >> $GITHUB_OUTPUT
          echo "COMMIT_MESSAGES<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MESSAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "FILES_CHANGED<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES_CHANGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "CHANGES_SUMMARY<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGES_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Validate with Gemini CLI
        id: validation
        uses: google-github-actions/run-gemini-cli@v0.1.11
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          settings: |
            {
              "model": "gemini-1.5-flash",
              "generationConfig": {
                "responseMimeType": "application/json"
              }
            }
          prompt: |
            Validate this contribution to TDD Guard project and provide specific improvements.

            PROJECT CONTEXT: TDD Guard is a Claude Code hook that enforces Test-Driven Development.

            GUIDELINES:
            - Use conventional commits (type: description)
            - PR titles must be descriptive and use conventional format
            - Commit messages must explain WHY, not WHAT
            - PRs need clear descriptions explaining changes and purpose

            CURRENT CONTRIBUTION:
            PR Title: "${{ steps.pr-info.outputs.PR_TITLE }}"
            PR Description: "${{ steps.pr-info.outputs.PR_BODY }}"
            Commit Messages: ${{ steps.pr-info.outputs.COMMIT_MESSAGES }}
            Commit Count: ${{ steps.pr-info.outputs.PR_COMMITS }}
            Files Changed: ${{ steps.pr-info.outputs.FILES_CHANGED }}

            CHANGES MADE:
            ${{ steps.pr-info.outputs.CHANGES_SUMMARY }}

            CRITICAL: You MUST respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or code blocks. Return raw JSON only.

            Format your response as valid JSON in this exact structure:
            {
              "status": "PASS",
              "issues": [],
              "improved_commits": "",
              "improved_title": "",
              "improved_description": ""
            }

            Rules:
            - status must be exactly "PASS", "FAIL", or "WARNINGS" 
            - issues must be an array of strings (use [] if empty)
            - improved_* fields must be strings (use "" if empty)
            - Do not wrap in ```json or any other formatting
            - Do not add any text before or after the JSON
            - Ensure the JSON is valid and parseable

      - name: Format Validation Results
        id: format
        run: |
          # Store raw output in temp file
          cat << 'RAWEOF' > /tmp/raw_output.txt
          ${{ steps.validation.outputs.summary }}
          RAWEOF

          # Extract JSON from markdown code blocks if present
          if grep -q '```json' /tmp/raw_output.txt; then
            # Extract content between ```json and ```
            sed -n '/```json/,/```/p' /tmp/raw_output.txt | sed '1d;$d' > /tmp/raw_output.json
          else
            # Use raw output as-is
            cp /tmp/raw_output.txt /tmp/raw_output.json
          fi

          # Validate JSON format
          if ! jq empty /tmp/raw_output.json 2>/dev/null; then
            echo "ERROR: Invalid JSON response from AI"
            echo "Raw output:"
            cat /tmp/raw_output.txt
            echo "Extracted JSON:"
            cat /tmp/raw_output.json
            # Fallback to simple parsing if JSON is invalid
            echo '{"status": "FAIL", "issues": ["Invalid AI response format"], "suggestions": [], "improved_title": "", "improved_commits": "", "improved_description": ""}' > /tmp/raw_output.json
          fi

          # Extract values from JSON
          STATUS=$(jq -r '.status' /tmp/raw_output.json)

          # Format issues as markdown list
          ISSUES_FORMATTED=""
          if [ "$(jq -r '.issues | length' /tmp/raw_output.json)" -gt 0 ]; then
            ISSUES_FORMATTED=$(jq -r '.issues[] | "- " + .' /tmp/raw_output.json)
          fi


          # Extract improved content
          IMPROVED_TITLE=$(jq -r '.improved_title // ""' /tmp/raw_output.json)
          IMPROVED_COMMITS=$(jq -r '.improved_commits // ""' /tmp/raw_output.json)
          IMPROVED_DESCRIPTION=$(jq -r '.improved_description // ""' /tmp/raw_output.json)

          # Determine status emoji and message
          if [[ "$STATUS" == "PASS" ]]; then
            STATUS_EMOJI="‚úÖ"
            STATUS_TEXT="Passed"
            STATUS_MESSAGE="Great work! Your contribution meets our guidelines."
          elif [[ "$STATUS" == "WARNINGS" ]]; then
            STATUS_EMOJI="‚ö†Ô∏è"
            STATUS_TEXT="Passed with Warnings"
            STATUS_MESSAGE="Your contribution looks good, but consider these suggestions for improvement."
          else
            STATUS_EMOJI="‚ùå"
            STATUS_TEXT="Needs Improvement"
            STATUS_MESSAGE="Your contribution needs some changes to meet our guidelines."
          fi

          # Build formatted markdown
          FORMATTED_BODY="## ü§ñ Contribution Validation Results"
          FORMATTED_BODY="$FORMATTED_BODY\n\n### Status: $STATUS_EMOJI $STATUS_TEXT"
          FORMATTED_BODY="$FORMATTED_BODY\n$STATUS_MESSAGE"

          if [[ -n "$ISSUES_FORMATTED" ]]; then
            FORMATTED_BODY="$FORMATTED_BODY\n\n### üìã Issues Found:"
            FORMATTED_BODY="$FORMATTED_BODY\n$ISSUES_FORMATTED"
          fi


          # Add improved content sections if available
          if [[ -n "$IMPROVED_TITLE" || -n "$IMPROVED_COMMITS" || -n "$IMPROVED_DESCRIPTION" ]]; then
            FORMATTED_BODY="$FORMATTED_BODY\n\n### ‚ú® Specific Improvements:"
          fi

          if [[ -n "$IMPROVED_COMMITS" ]]; then
            FORMATTED_BODY="$FORMATTED_BODY\n\n#### üìã Suggested Commit Message:"
            FORMATTED_BODY="$FORMATTED_BODY\n\`\`\`"
            FORMATTED_BODY="$FORMATTED_BODY\n$IMPROVED_COMMITS"
            FORMATTED_BODY="$FORMATTED_BODY\n\`\`\`"
          fi

          if [[ -n "$IMPROVED_TITLE" ]]; then
            FORMATTED_BODY="$FORMATTED_BODY\n\n#### üìù Suggested PR Title:"
            FORMATTED_BODY="$FORMATTED_BODY\n\`\`\`"
            FORMATTED_BODY="$FORMATTED_BODY\n$IMPROVED_TITLE"
            FORMATTED_BODY="$FORMATTED_BODY\n\`\`\`"
          fi

          if [[ -n "$IMPROVED_DESCRIPTION" ]]; then
            FORMATTED_BODY="$FORMATTED_BODY\n\n#### üìÑ Suggested PR Description:"
            FORMATTED_BODY="$FORMATTED_BODY\n\`\`\`"
            FORMATTED_BODY="$FORMATTED_BODY\n$IMPROVED_DESCRIPTION"
            FORMATTED_BODY="$FORMATTED_BODY\n\`\`\`"
          fi

          FORMATTED_BODY="$FORMATTED_BODY\n\n---"
          FORMATTED_BODY="$FORMATTED_BODY\n*Automated validation based on our [contribution guidelines](CONTRIBUTING.md).*"
          FORMATTED_BODY="$FORMATTED_BODY\n*If you believe this is incorrect, please mention a maintainer for review.*"

          # Output formatted result using heredoc for multiline
          echo "FORMATTED_BODY<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FORMATTED_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Also output simple status for status checks
          echo "STATUS=$STATUS" >> $GITHUB_OUTPUT

      - name: Post Validation Results
        uses: actions/github-script@v7
        env:
          FORMATTED_RESULT: ${{ steps.format.outputs.FORMATTED_BODY }}
          VALIDATION_STATUS: ${{ steps.format.outputs.STATUS }}
        with:
          script: |
            // Use environment variable to safely pass the formatted result
            const formattedResult = process.env.FORMATTED_RESULT;
            const status = process.env.VALIDATION_STATUS;
            const prNumber = context.payload.pull_request.number;

            // Determine if validation passed
            const isPassing = status === 'PASS';
            const hasWarnings = status === 'WARNINGS';

            // Find existing comment to update instead of creating duplicates
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ü§ñ Contribution Validation Results')
            );

            // Add timestamp to the result
            const timestamp = new Date().toISOString().replace('T', ' ').split('.')[0] + ' UTC';
            const bodyWithTimestamp = formattedResult + '\n\n_Last updated: ' + timestamp + '_';

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: bodyWithTimestamp
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: bodyWithTimestamp
              });
            }

            // Set status check
            const state = isPassing ? 'success' :
                          hasWarnings ? 'pending' : 'failure';
            const description = isPassing ? 'All guidelines met' :
                               hasWarnings ? 'Minor issues found' :
                               'Guidelines violations detected';

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              target_url: `https://github.com/${context.repo.owner}/` +
                `${context.repo.repo}/actions/runs/${context.runId}`,
              description: description,
              context: 'Contribution Validator'
            });

      - name: Handle Validation Failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;

            // Find existing comment to update instead of creating duplicates
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              (comment.body.includes('ü§ñ Contribution Validation Results') ||
               comment.body.includes('‚ö†Ô∏è Validation Service Unavailable'))
            );

            // Add timestamp to the error message
            const timestamp = new Date().toISOString().replace('T', ' ').split('.')[0] + ' UTC';
            const errorBody = `## ‚ö†Ô∏è Validation Service Unavailable\n\n` +
              `The AI-powered contribution validator is ` +
              `temporarily unavailable. ` +
              `This could be due to:\n- API rate limits\n- Service outage\n` +
              `- Network issues\n\n**Manual Review Required**: ` +
              `Please ensure your contribution ` +
              `follows our ` +
              `[guidelines](CONTRIBUTING.md):\n` +
              `- Commit messages use conventional format\n` +
              `- PR title is descriptive\n` +
              `- Description explains what and why\n\n` +
              `A maintainer will review this PR manually.\n\n` +
              `_Last updated: ${timestamp}_`;

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: errorBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: errorBody
              });
            }

            // Set neutral status - don't block the PR
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: 'success',
              target_url: `https://github.com/${context.repo.owner}/` +
                `${context.repo.repo}/actions/runs/${context.runId}`,
              description: 'Validation skipped - service unavailable',
              context: 'Contribution Validator'
            });
